def find_lowest_node (self, node, x):
    if (node.value < x):
        return node
    elif (node.parent != None):
        return self.find_lowest_node(node.parent, x)
    else:
        return None

def add_node (self, x):
    new_node = Node()
    new_node.value = x
    
    if (self.root == None):
        self.last = new_node
        self.root = new_node
        return
    
    node_z = self.find_lowest_node(self.last, x)
    
    if (node_z == None):
        new_node.left = self.root
        self.root.parent = new_node
        self.root = new_node
    else:
        new_node.left = node_z.right
        node_z.right = new_node
        new_node.parent = node_z
        
    self.last = new_node
    
def in_order_traversal(self, node):
    if (node == None):
        return
    self.in_order_traversal(node.left)
    print(node.value)
    self.in_order_traversal(node.right)
    
#FUNÇÃO QUE REALIZA O SORTING
    
def cartesian_tree_sort (self, sorted_ar):
    p_queue = NodesPriorityQueue()
    p_queue.push(self.root)
    temp = None
        
    while not(p_queue.isEmpty()):
        temp = p_queue.smallest()
        
        #print("Começo do código, maior valor da PriorityQueue, no caso, a raiz da árvore:")
        #print(p_queue.smallest().value)
        
        p_queue.pop() 
        #print("Priority Queue depois do pop: "+ p_queue.toString())
        sorted_ar.append(temp.value)
        #print("lista ordenada até o momento: " + str(sorted_ar))
        if (temp.left != None):
            p_queue.push(temp.left)
            #print(temp.left.value)
            #p_queue.push(temp.left)
        if(temp.right != None):
            #print(temp.right.value)
            p_queue.push(temp.right)

class Node():
    def __init__ (self):
        self.value = 0
        self.left = None
        self.right = None
        self.parent = None

def push (self, node):
    index = None
    if self.queue == []:
        self.queue.append(node)
    else:
        for i in range(len(self.queue)):
            if node.value <= self.queue[i].value:
                index = i+1
        if index == None:
            self.queue.insert(0,node)
        else:
            self.queue.insert(index,node)

#Check if the queue is empty
def isEmpty(self):
    if self.queue == [] or self.queue == None:
        return True
    else:
        return False

#Return the smallest value in the queue
def smallest (self):
    if self.queue == [] or self.queue == None:
        return None
    else:
        max_value = self.queue[0]
        for i in range(len(self.queue)):
            if self.queue[i].value <= max_value.value:
                max_value = self.queue[i]
        return max_value

def pop (self):
    if self.queue == [] or self.queue == None:
        return None
    else:
        min_value_index = 0
        for i in range(len(self.queue)):
            if self.queue[i].value <= self.queue[min_value_index].value:
                min_value_index = i
        del self.queue[i]